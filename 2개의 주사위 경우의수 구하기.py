# 두 개의 정 N면체와 정 M면체의 두 개의 주사위를 던져서
# 나올 수 있는 눈의 합 중 가장 확률이 높은 숫자를 출력하는 프로그램을 작성하세요.
# 정답이 여러 개일 경우 오름차순으로 출력합니다

# 각 주사위의 숫자들을 하나씩 더하면서 모든 경우의 수를 리턴
# 해당 경우의 수 중에 중복 되는 값이 있다면 숫자가 큰 숫자로 출력

n1, n2 = map(int, input().split())
mx = 0
ls = [0]*(n1+n2) # 주사위의 중첩 값을 카운트 해줄 list
result = []

total = []
for i in range(1,n1 + 1) : # 첫번째 주사위가 나올 수 있는 모든 수
    for j in range(1,n2 + 1) : #두번째 주사위가 나올 수 있는 모든 수
        tt = i + j # 각 주사위를 더한 숫자를 tt에 할당
        ls[tt -1] = ls[tt -1] +1 # 각 더한 값들이 들어올때 마다 ls 리스트에 하나씩 카운트 해줌
        # 0, 1, 2, 3, 4, 4, 4, 3, 2, 1 이런 식으로 들어옴
        # ex ) 숫자1 = 0번 중첩, 숫자2 = 1번 중첩, 숫자3 = 2번 중첩, 숫자4 = 3번 중첩, 숫자 5,6,7 = 4번 충첩

# 모든 경우의 수가 담긴 list인 ls를 만들었으니
# 이제부터 해당 ls의 값을 하나씩 빼오면서 가장 높을 경우의 수를 찾을 차례

for i in ls :
    if mx < i : # 이전에 나온 값과 비교해서 현재 값이 크다면
        mx = i  # 현재 값 추가


# 위의 반복문으로 최대 중첩 값을 찾았다면 이제 해당 숫자를 리스트에 저장
for inx, i in enumerate(ls) : # inx = 인덱스 위치 , i = 중첩 횟수
    if i == mx : # 중첩 되는 횟수가 위에서 구한 최대 중첩 값과 같다면 아래 구문 실행
        result.append(inx + 1) # 최종 최대 경우의 수를 담는 list에 해당 숫자를 추가

# 이제 반복문을 통해서 결과를 담은 list를 하나씩 빼오면서 출력
result.sort() # 해당 리스트 정렬

for i in result :
    print(i, end=" ")


