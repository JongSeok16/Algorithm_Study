n = int(input())
ls = list(map(int, input().split()))

# N개의 자연수가 입력되면 각 자연수를 뒤집은 후 그 뒤집은 수가 소수이면
# 그 수를 출력하는 프로그램을 작성하세요. 예를 들어 32를 뒤집으면 23이고,
# 23은 소수이다. 그러면 23을 출력 한다. 단 910를 뒤집으면 19로 숫자화 해야 한다.
# 첫 자리부터의 연속된 0은 무시한다. 뒤집는 함수인 def reverse(x) 와
# 소수인지를 확인하는 함수 def isPrime(x)를 반드시 작성하 여 프로그래밍 한다.

# 위의 문제는 함수 2개를 필요로 한다
# 첫번째 숫자의 자릿수를 뒤집는 함수
# 두번째 뒤집은 숫자가 소수인지 확인하는 함수

# 먼저 숫자의 자릿수를 뒤집는 방법은 다음과 같다


# 자리수를 뒤집는 함수
def reverse(x) :
    lss = []  # 인자로 받아온 list의 각각의 수 들을 뒤집은 값을 넣을 배열
    result = [] # lss에서 뒤집은 숫자들 중 앞자리가 0인경우 0을 제외시킨 반환값을 넣을 배열

    # 가장먼저 인자로 받아온 숫자를 뒤집는 반복 루프

    for i in x :
        s = str() # 숫자를 차례대로 합쳐주기위해 문자형 자료형을 선언
        while i > 0 :
            d = i % 10 # i / 10 을 해서 남은 값을 하나씩 문자형으로 더해주면 자리가 뒤집어짐
            d = str(d) # 위에서 정수형으로 계산 했기 때문에 문자형 형태로 붙여주기 위해 str 으로 형변환
            s = s + d  # 기존의 나머지 값에 현재 나머지 값을 더해줌 ( 문자열 형태로 더 해줌 )
            i = i // 10 # i를 계속 i / 10 의 몫 값으로 할당해 더이상 i를 10으로 나눌수 없을 때 까지 반복문 실행
        lss.append(s) # 최종적으로 남은 s 변수에는 뒤집힌 값이 있음 배열에 추가 시켜줌



    # 위에서 뒤집어서 추가해준 배열을 가지고와
    # 앞이 0으로 시작되는 숫자는 0을 제거
    # ex : 001 -> 1

    # 방법은 간단
    # 앞에서 부터 차례대로 0과 맞는지 비교하며 만약 0이 아닌 경우
    # 해당 인덱스의 위치부터 나머지 뒤의 값을 변수에 담고
    # return 해줄 배열에 추가시켜주면 됨

    for i in lss :
        for e in range(len(i)) : # 해당 리스트의 인덱스 번호들이 차례대로 넘어옴
            if i[e] != "0" : # 해당 인덱스의 값이 0이 아닐경우
                rs = i[e:] # 해당 인덱스의 위치부터 끝까지 rs 변수에 할당
                result.append(rs)
                break # 반환해줄 값에 넣어주었다면 해당 반복문 탈출
    return result




# 소수확인 함수

# 에라토스테네스의 체 알고리즘을 사용해서
# 소수인지 확인 후 맞다면 리턴해줄 배열에 추가해서
# 반복문이 끝나면 반환

def isPrime(x) :
    result = [] # 소수로 걸러진 값들을 리턴해줄 배열
    for ins, i in enumerate(x) :
        if i == '1' : # 1의 값은 소수가 아니기때문에 건너뛰기
            continue

        d = int(i) # 현재 숫자는 문자형 이므로 정수형으로 형변환

        ls = [0] * d # 해당하는 숫자의 크기만큼 list 생성
                     # 숫자가 35라면 35개의 인덱스 생성

        for e in range(2, d+1) : # 2부터 시작해서 주어진 정수까지 for 루프 실행
            if ls[e-1] == 0 : # 아래의 과정을 계속 거치면서 주어진 정수가 소수인지 걸러줌
                for i in range(e*2, d+1, e): # 처음 2가 들어올 경우 2의 배수에 해당하는 인덱스는 전부 count + 1
                    ls[i-1] = 1

        if ls[d-1] == 0 : # 위의 for 루프가 끝나고 최종적으로 남은 리스트는 주어진 정수와 작거나 같은 소수의 부분만 0의 값이 들어있음
                          # 즉 해당 배열의 마지막 index는 현재 정수가 소수인지 count 된 값이 들어있고 0일경우 소수임
            result.append(x[ins]) # 소수일 경우 반환값에 추가
    return result

for i in isPrime(reverse(ls)):
    i = int(i)
    print(i, end=" ")